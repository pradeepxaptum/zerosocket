<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<title>Zero Socket by xaptum</title>

<link rel="stylesheet" href="stylesheets/styles.css">
<link rel="stylesheet" href="stylesheets/pygment_trac.css">
<script src="javascripts/scale.fix.js"></script>
<script src="javascripts/jquery-1.10.2.js"></script>
<script src="javascripts/jquery-ui.js"></script>
<!-- 	<link rel="stylesheet" href="/resources/demos/style.css">
<!-- <link rel="stylesheet" href="//code.jquery.com/ui/1.11.1/themes/smoothness/jquery-ui.css">
<script src="//code.jquery.com/jquery-1.10.2.js"></script>
<script src="//code.jquery.com/ui/1.11.1/jquery-ui.js"></script> -->
<!-- 	<link rel="stylesheet" href="/resources/demos/style.css"> -->

<script>
	$(function() {
		$("#manuals").accordion({
			heightStyle: "content"
		});
	});
</script>
<meta name="viewport"
	content="width=device-width, initial-scale=1, user-scalable=no">
<!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
	<div class="wrapper">
		<header>
			<h1 class="header">Zero Socket</h1>
			<p class="header">Implementation of ZeroSocket, a federated
				security protocol</p>

			<ul>
				<li class="download"><a class="buttons"
					href="https://github.com/xaptum/zerosocket/zipball/master">Download
						ZIP</a></li>
				<li class="download"><a class="buttons"
					href="https://github.com/xaptum/zerosocket/tarball/master">Download
						TAR</a></li>
				<li><a class="buttons github"
					href="https://github.com/xaptum/zerosocket">View On GitHub</a></li>
			</ul>

			<p class="header">
				This project is maintained by <a class="header name"
					href="https://github.com/xaptum"> <img alt="Xaptum"
					style="width: 100%;" src="images/XaptumT_400x200.png"></a>
			</p>


		</header>
		<section>
			<h1>
				<a name="zero-socket" class="anchor" href="#zero-socket"><span
					class="octicon octicon-link"></span></a>Zero Socket
			</h1>

			<p>Zero Socket is a minimalistic socket interceptor. It can be
				easily integrated into resource-limited or embedded projects.</p>

			<p>
				Read more about Zero Socket format at <a
					href="http://xaptum.com/zerosocket">xaptum.com/zerosocket</a>
			</p>

			<p>
				Library sources are available at <a
					href="https://github.com/xaptum/zerosocket">github.com/xaptum/zerosocket</a>
			</p>

			<h2>
				<a name="philosophy" class="anchor" href="#philosophy"><span
					class="octicon octicon-link"></span></a>Philosophy
			</h2>

			<p>Most client side libraries are meant to add a protocol layer.
				However the socket and network layer needs to be managed independent
				of the application layer protocol</p>

			<h2>
				<a name="features" class="anchor" href="#features"><span
					class="octicon octicon-link"></span></a>Features
			</h2>

			<ul>
				<li>compatible with C++99 or later</li>
				<li>standard dependencies (even libc , libc++)</li>
				<li>highly portable (tested on x86/amd64, ARM)</li>
				<li>extremely small code footprint</li>
				<li>compile time control through -D options</li>
				<li>no dynamic memory allocation</li>
				<li>library code is covered with unit-tests</li>
			</ul>
			<h2>
				<a name="design" class="anchor" href="#design"><span
					class="octicon octicon-link"></span></a>Design
			</h2>

			<h2>
				<a name="install" class="anchor" href="#install"><span
					class="octicon octicon-link"></span></a>Install
			</h2>

			<p>To clone the repository you should have git client installed.
				Just run:</p>

			<pre><code>$ git clone https://github.com/xaptum/zerosocket.git</code></pre>

			<h2>
				<a name="api" class="anchor" href="#api"><span
					class="octicon octicon-link"></span></a>API
			</h2>

			<div id="manuals">
				<h3><a href="#">Global variables</a></h3>
				<div class="manual" id="GlobalVars">
					<h5 id="const-char-const-zselementdesc">const char* const
						ZSElementDesc[]</h5>
					<p>
						<strong>Initial value:</strong>
						<pre><code>{ &quot;UNKNOWN&quot;, &quot;ProtocolVersion&quot;,
&quot;Username&quot;, &quot;Password&quot;, &quot;Token&quot;,
&quot;Date&quot;, &quot;DeviceId&quot;, &quot;Method&quot;,
&quot;Address&quot;, &quot;Port&quot;, &quot;Origin&quot;,
&quot;Destination&quot; }</code></pre>
					</p>
					<h5 id="const-char-const-zselementname">const char* const
						ZSElementName[]</h5>
					<p>
						<strong>Initial value:</strong>
						<pre><code>{ &quot;UNKN&quot;, &quot;zver&quot;,
&quot;zusr&quot;, &quot;zpas&quot;, &quot;ztok&quot;,
&quot;zdat&quot;, &quot;zdid&quot;, &quot;zmet&quot;,
&quot;zadr&quot;, &quot;zprt&quot;, &quot;zorg&quot;,
&quot;zdst&quot; }</code></pre>
					</p>
				</div>


				<h3><a href="#">Global macros</a></h3>
				<div class="manual" id="GlobalMacros">
					<pre><code>#define SIZEOFARRAY(ARR)    sizeof(ARR)/sizeof(*ARR)
#define ZSMAXNAMESZ         10
#define ZSMAXVALUSZ         1536</code></pre>
					<h4 id="enumerations">Enumerations</h4>
					<pre><code>enum ZSElement {
    ZUNK = 0,
    ZVER, // 1
    ZUSR, // 2
    ZPAS, // 3
    ZTOK, // 4
    ZDAT, // 5
    ZDID, // 6
    ZMET, // 7
    ZADR, // 8
    ZPRT, // 9
    ZORG, // 10
    ZDST  // 11
 }</code></pre>
				</div>




				<h3>
					<a href="#">enum ZSElement
						getZSElementIndex(const char * name) ;</a>
				</h3>
				<div class="manual" id="getZSElementIndex">
					<h5 id="enum-zselement-getzselementindex-const-char-name">
						enum ZSElement getZSElementIndex ( const char* <em>name</em> )
					</h5>
					<p>Get Zero Socket Element Index from name(String) . This
						function does a case insensitive string compare to known zero
						socket keys.</p>
					<h6 id="parameters">Parameters:</h6>
					<p>name as a string</p>
					<h6 id="returns">Returns:</h6>
					<p>appropriate ZSElement when key matches, on error returns
						ZUNK</p>
				</div>


				<h3>
					<a href="#">const char * getZSVersion(void);</a>
				</h3>
				<div class="manual" id="getZSVersion">
					<h5 id="const-char-getzsversion-void">const char* getZSVersion
						( void* )</h5>
					<h6 id="returns">Returns:</h6>
					<p>returns the current library version of protocol supported</p>
					<hr>
				</div>


				<h3>
					<a href="#">int zsocket (int family, int type, int protocol);</a>
				</h3>
				<div class="manual" id="zsocket">
					<p>zsocket() call creates an interceptor for the socket system
						call. Currently supported implementation is for TCP(Stream) and
						UDP(Datagram)</p>
					<h6 id="example-usage">Example usage:</h6>
					<pre><code>#include &quot;zerosocket.h&quot;
&#8942;
int server_sock;
&#8942;
server_sock = zsocket (AF_INET, SOCK_STREAM, 0);</code></pre>
					<h6 id="parameters">Parameters</h6>
					<p>
						<table>
							<tr><th>Parameter</th><th>Description</th></tr>
							<tr><td>family</td><td>The family parameter specifies a communications domain
								within which communication will take place; this selects the
								protocol family which should be used. These families are defined
								in the include file &lt;sys/socket.h&gt;. The currently understood
								formats are PF_INET Internet version 4 protocols, PF_INET6
								Internet version 6 protocols</td></tr>
							<tr><td>type</td><td>The socket has the
								indicated type, which specifies the semantics of communication.
								Currently defined types are: SOCK_STREAM SOCK_DGRAM SOCK_RAW
								SOCK_SEQPACKET SOCK_RDM</td></tr>
							<tr><td>protocol</td><td>The protocol specifies a
								particular protocol to be used with the socket. Normally only a
								single protocol exists to support a particular socket type within
								a given protocol family. However, it is possible that many
								protocols may exist, in which case a particular protocol must be
								specified in this manner. The protocol number to use is particular
								to the communication domain in which communication is to take
								place;</td></tr>
							<!-- <tr><td></td><td></td></tr>
							<tr><td></td><td></td></tr> -->
						</table>
					</p>
					<h6 id="returns">Returns</h6>
					<p>returns the socket descriptor for the newly created socket</p>
					<h6 id="see-also">See Also</h6>
					<p>
						<a href="http://man7.org/linux/man-pages/man5/protocols.5.html">protocols</a>
					</p>
					<p>
						<a href="http://man7.org/linux/man-pages/man2/socket.2.html">socket</a>
						for error return values
					</p>
					<hr>
				</div>

				<h3>
					<a href="#">int zconnect(int sockfd, struct sockaddr
						*serv_addr, int addrlen);</a>
				</h3>
				<div class="manual" id="zconnect">
					<h5 id="int-zconnect-int-sockfd-struct-sockaddr-serv_addr-int-addrlen">
						int zconnect ( int <em>sockfd</em>, struct sockaddr * <em>serv_addr</em>,
						int <em>addrlen</em> )
					</h5>
					<p>zconnect() intercepts the 'connect' system call. ipv6 Connect is
						not yet supported, to be available shortly. The zconnect() call
						connects the socket referred to by the file descriptor sockfd to the
						address specified by addr.</p>
					<h6 id="example-usage">Example usage:</h6>
					<pre><code>#include &quot;zerosocket.h&quot;
&#8942;
int rc;
int client_sock;
struct sockaddr_in server_addr;
&#8942;
memset(&amp;server_addr, 0,sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_port = 5001;
server_addr.sin_addr.s_addr = inet_addr(&quot;129.5.24.1&quot;);
rc = zconnect(client_sock, (struct sockaddr *) &amp;server_addr, sizeof(server_addr));</code></pre>
					<h6 id="parameters">Parameters</h6>
					<table>
						<thead>
							<tr>
								<th>Parameters</th>
								<th style="text-align: left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>sockfd</td>
								<td style="text-align: left">The socket descriptor for the
									connection as returned by zsocket call</td>
							</tr>
							<tr>
								<td>serv_addr</td>
								<td style="text-align: left">The format of the address in
									addr is determined by the address space of the socket sockfd</td>
							</tr>
							<tr>
								<td>addrlen</td>
								<td style="text-align: left">The addrlen argument specifies
									the size of addr</td>
							</tr>
						</tbody>
					</table>
					<h6 id="returns">Returns</h6>
					<p>Upon successful completion, a value of 0 is returned. Otherwise,
						a value of -1 is returned and the global integer variable errno is set
						to indicate the error.</p>
					<h6 id="see-also">See Also</h6>
					<p>zsocket() for further details.</p>
					<p>
						connect <a href="http://man7.org/linux/man-pages/man2/connect.2.html">man
							connect</a> for details on error return.
					</p>
					<hr>
				</div>

				<h3>
					<a href="#">int zbind(int sockfd, struct sockaddr *my_addr,int addrlen);</a>
				</h3>
				<div class="manual" id="zbind">
					<h5 id="int-zbind-intsockfd-struct-sockaddr-my_addr-int-addrlen">
						int zbind ( int <em>sockfd</em>, struct sockaddr * <em>my_addr</em>,
						int <em>addrlen</em> )
					</h5>
					<p>zbind() call intercepts the bind system call.</p>
					<p>zbind() assigns the address specified by addr to the socket
						referred to by the file descriptor sockfd. addrlen specifies the
						size, in bytes, of the address structure pointed to by addr.</p>
					<h6 id="example-usage">Example usage:</h6>
					<pre><code>#include &quot;zerosocket.h&quot;
&#8942;
int rc;
int s;
struct sockaddr_in myname;
&#8942;
// bind to all interfaces
memset(&amp;myname, 0, sizeof(myname));
myname.sin_family = AF_INET;
myname.sin_port = 5001;
myname.sin_addr.s_addr = INADDR_ANY; // all interfaces
rc = zbind (s, (struct sockaddr *) &amp;myname, sizeof(myname));</code></pre>
					<h6 id="parameters">Parameters</h6>
					<p>
					<table>
						<tr>
							<th>Parameter</th>
							<th>Description</th>
						</tr>
						<tr>
							<td>sockfd</td>
							<td>unassigned socket file descriptor as assigned by zsocket
								call, do not use return value from socket call to this function</td>
						</tr>
						<tr>
							<td>my_addr</td>
							<td>The actual structure passed for the my_addr argument
								will depend on the address family. The sockaddr structure is
								defined as something like <br><pre><code>struct sockaddr { sa_family_t sa_family; char sa_data[14]; }</code></pre></td>
						</tr>
						<tr>
							<td>addrlen</td>
							<td>length of the my_addr, depends on the address family</td>
						</tr>
					</table>
					</p>
					<h6 id="returns">Returns</h6>
					<p>On success, zero is returned. On error, -1 is returned, and
						errno is set appropriately.</p>
					<h6 id="see-also">See Also</h6>
					<p>
						bind <a href="http://man7.org/linux/man-pages/man2/bind.2.html">man
							bind</a>.
					</p>
					<hr>
				</div>

				<h3>
					<a href="#">int zlisten(int sockfd,int backlog);</a>
				</h3>
				<div class="manual" id="getZSElementIndex">
					<h5 id="int-zlisten-int-sockfd-int-backlog">
						int zlisten ( int <em>sockfd</em>, int <em>backlog</em> )
					</h5>
					<p>zlisten() call intercepts the listen system call.</p>
					<p>zlisten() marks the socket referred to by sockfd as a
						passive socket, that is, as a socket that will be used to accept
						incoming connection requests using zaccept.</p>
					<pre><code>#include &quot;zerosocket.h&quot;
&#8942;
int rc;
int server_sock;
&#8942;
rc = zlisten(server_sock,5);</code></pre>
					<h6 id="parameters">Parameters</h6>
					<table>
						<tr>
							<th>parameter</th>
							<th>Description</th>
						</tr>
						<tr>
							<td>sockfd</td>
							<td>The sockfd argument is a file descriptor that refers to
								a socket of type SOCK_STREAM or SOCK_SEQPACKET.</td>
						</tr>
						<tr>
							<td>backlog</td>
							<td>The backlog argument defines the maximum length to which
								the queue of pending connections for sockfd may grow.</td>
						</tr>
					</table>
					<h6 id="returns">Returns</h6>
					<p>On success, zero is returned. On error, -1 is returned, and
						errno is set appropriately.</p>
					<h6 id="see-also">See Also</h6>
					<p><a href="#">zaccept ()</a></p>
					<p>
						zlisten <a
							href="http://man7.org/linux/man-pages/man2/listen.2.html">man
							listen</a>
					</p>
				</div>

				<h3>
					<a href="#">int zaccept (int sockfd, struct sockaddr
						*cliaddr, socklen_t *addrlen);</a>
				</h3>
				<div class="manual" id="zaccept">
					<h5
						id="int-zaccept-intsockfd-struct-sockaddr-cliaddr-socklen_t-addrlen">
						int zaccept ( int <em>sockfd</em>, struct sockaddr * <em>cliaddr</em>,
						socklen_t * <em>addrlen</em> )
					</h5>
					<p>zaccept() call intercepts the accept system call.</p>
					<p>zaccept() used with connection-based socket types
						(SOCK_STREAM, SOCK_SEQPACKET), It extracts the first connection
						request on the queue of pending connections for the listening
						socket, sockfd, creates a new connected socket, and returns a new
						file descriptor referring to that socket.</p>
					<h6 id="example-usage">Example usage:</h6>
					<pre><code>#include &quot;zerosocket.h&quot;
&#8942;
int newclient_sock;
int server_sock;
struct sockaddr client_addr;
int addrlen;
//zsocket, zbind, and zlisten have been called
&#8942;
addrlen = sizeof(client_addr);
newclient_sock = zaccept((server_sock,&amp;client_addr, &amp;addrlen));</code></pre>
					<h6 id="parameters">Parameters:</h6>
					<table>
						<tr>
							<th>Parameter</th>
							<th>Description</th>
						</tr>
						<tr>
							<td>sockd</td>
							<td>sockfd is a socket that has been created with zsocket,
								bound to a local address with zbind, and is listening for
								connections after a zlisten</td>
						</tr>
						<tr>
							<td>cliaddr</td>
							<td>cliaddr is a pointer to a sockaddr structure. This
								structure is filled in with the address of the peer socket, as
								known to the communications layer</td>
						</tr>
						<tr>
							<td>addrlen</td>
							<td>addrlen argument is a value-result argument: the caller
								must initialize it to contain the size (in bytes) of the
								structure pointed to by addr; on return it will contain the
								actual size of the peer address</td>
						</tr>
					</table>
					<h6 id="returns">Returns</h6>
					<p>On success, these system calls return a nonnegative integer
						that is a descriptor for the accepted socket. On error, -1 is
						returned, and errno is set appropriately.</p>
					<h6 id="see-also">See Also</h6>
					<p><a href="#">zsocket ()</a></p>
					<p><a href="#">zbind ()</a></p>
					<p><a href="#">zlisten ()</a></p>
					<p>
						accept <a
							href="http://man7.org/linux/man-pages/man2/accept.2.html">man
							accept</a>
					</p>
					<hr>
				</div>

				<h3>
					<a href="#">int zsend(int sockfd, const void *msg, int
						len, int flags);</a>
				</h3>
				<div class="manual" id="zsend">
					<h5 id="int-zsend-int-sockfd-const-void-msg-int-len-int-flags">
						int zsend ( int <em>sockfd</em>, const void * <em>msg</em>, int <em>len</em>,
						int <em>flags</em>)
					</h5>
					<p>zsend() call intercepts the send system call.</p>
					<p>zsend() call may be used only when the socket is in a
						connected state (so that the intended recipient is known).</p>
					<h6 id="example-usage">Example Usage:</h6>
					<pre><code>#include &quot;zerosocket.h&quot;
&#8942;
int bytes_sent;
int server_sock;
char data_sent[256];
&#8942;
bytes_sent = zsend(server_sock,data_sent, sizeof(data_sent), 0);</code></pre>
					<h6 id="parameters">Parameters</h6>
					<table>
						<tr>
							<th>Parameter</th>
							<th>Description</th>
						</tr>
						<tr>
							<td>sockfd</td>
							<td>The sockfd argument is a file descriptor that refers to
								a socket of type SOCK_STREAM or SOCK_SEQPACKET</td>
						</tr>
						<tr>
							<td>msg</td>
							<td>The message is found in msg</td>
						</tr>
						<tr>
							<td>len</td>
							<td>length of data to send in msg</td>
						</tr>
						<tr>
							<td>flags</td>
							<td>see send manual or follow link below to see possible
								flags</td>
						</tr>
					</table>
					<h6 id="returns">Returns</h6>
					<p>On success, zero is returned. On error, -1 is returned, and
						errno is set appropriately.</p>
					<h6 id="see-also">See Also</h6>
					<p><a href="#">zsendto ()</a></p>
					<p>
						send <a href="http://man7.org/linux/man-pages/man2/send.2.html">man
							send</a>
					</p>
				</div>

				<h3>
					<a href="#">int zrecv(int sockfd, void *buf, size_t len,
						int flags);</a>
				</h3>
				<div class="manual" id="getZSElementIndex">
					<h5 id="int-zrecv-int-sockfd-void-buf-size_tlen-int-flags">
						int zrecv ( int <em>sockfd</em>, void * <em>buf</em>, size_t <em>len</em>,
						int <em>flags</em> )
					</h5>
					<p>zrecv() call intercepts the recv system call.</p>
					<p>zrecv() call may be used only when the socket is in a
						connected state (so that the intended recipient is known). the
						following call</p>
					<pre><code>zrecv (sockfd, buf, len, flags);</code></pre>
					<p>is equivalent to</p>
					<pre><code>zrecvfrom (sockfd,buf, len, flags, NULL, 0);</code></pre>
					<h6 id="example-usage">Example usage:</h6>
					<pre><code>#include &quot;zerosocket.h&quot;
&#8942;
int rc;
int server_sock;
char oob_data;
&#8942;
rc = zrecv (server_sock,oob_data,sizeof(oob_data),MSG_OOB);
if (rc &gt; 0)
{
// Process the oob data from the sender
&#8942;
}</code></pre>
					<h6 id="parameters">Parameters</h6>
					<table>
						<thead>
							<tr>
								<th>Parameter</th>
								<th style="text-align: left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>sockfd</td>
								<td style="text-align: left">The sockfd argument is a file
									descriptor that refers to a socket of type SOCK_STREAM or
									SOCK_SEQPACKET.</td>
							</tr>
							<tr>
								<td>buf</td>
								<td style="text-align: left">the message is found in buf</td>
							</tr>
							<tr>
								<td>len</td>
								<td style="text-align: left">length of data to send in buf</td>
							</tr>
							<tr>
								<td>flags</td>
								<td style="text-align: left">see send manual or follow link
									below to see possible flags</td>
							</tr>
						</tbody>
					</table>
					<h6 id="returns">Returns</h6>
					<p>On success, zero is returned. On error, -1 is returned, and
						errno is set appropriately.</p>
					<h6 id="see-also">See Also</h6>
					<p><a href="#">zrecvfrom ()</a></p>
					<p>
						recv <a href="http://man7.org/linux/man-pages/man2/recv.2.html">man
							recv</a>
					</p>
					<hr>
				</div>

				<h3>
					<a href="#">int zsendto(int sockfd, const void *msg,
						int len, int flags, const struct sockaddr *to, socklen_t tolen);</a>
				</h3>
				<div class="manual" id="zsendto">
					<h5
						id="int-zsendto-int-sockfd-const-void-msg-int-len-int-flags-const-struct-sockaddr-to-socklen_t-tolen">
						int zsendto ( int  <em>sockfd</em>, const void *  <em>msg</em>,
						int  <em>len</em>, int  <em>flags</em>, const struct sockaddr
						*  <em>to</em>, socklen_t  <em>tolen</em> )
					</h5>
					<p>zsendto() call intercepts the sendto system call.</p>
					<p>zsendto() call may be used only when the socket is set for
						Datagram. If zsendto() is used on a connection-mode (SOCK_STREAM,
						SOCK_SEQPACKET) socket, the arguments dest_addr and addrlen are
						ignored.</p>
					<p>
						The following call:
						<code>zsend(sockfd, buf, len, flags);</code>
						is equivalent to
						<code>zsendto(sockfd, buf, len, flags, NULL, 0);</code>
					</p>
					<h6 id="example-usage">Example usage:</h6>
					<pre><code>int bytes_sent;
int server_sock;
char send_msg[100];
struct sockaddr_in to_addr;
&#8942;
to_addr.sin_family = AF_INET;
to_addr.sin_port = 5001;
to_addr.sin_addr.s_addr = inet_addr(&quot;129.5.24.1&quot;);
bytes_sent =
zsendto (server_sock, send_msg, sizeof(send_msg), 0, (struct sockaddr *)&amp;to_addr, sizeof(to_addr));</code></pre>
					<h6 id="parameters">Parameters</h6>
					<table>
						<thead>
							<tr>
								<th>Parameter</th>
								<th>Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>sockfd</td>
								<td>The sockfd argument is a file descriptor that refers to
									a socket</td>
							</tr>
							<tr>
								<td>msg</td>
								<td>the message is found in buf</td>
							</tr>
							<tr>
								<td>len</td>
								<td>length of data to send in buf</td>
							</tr>
							<tr>
								<td>flags</td>
								<td>see send manual or follow link below to see possible
									flags</td>
							</tr>
							<tr>
								<td>to</td>
								<td>the address of the target is given by to</td>
							</tr>
							<tr>
								<td>tolen</td>
								<td>specifying the size of to structure</td>
							</tr>
						</tbody>
					</table>

					<h6 id="returns">Returns</h6>
					<p>On success, zero is returned. On error, -1 is returned, and
						errno is set appropriately.</p>
					<h6 id="see-also">See Also</h6>
					<p><a href="#">zsend ()</a></p>
					<p>
						sendto <a
							href="http://man7.org/linux/man-pages/man2/sendto.2.html">man
							sendto</a>
					</p>
					<hr>
				</div>

				<h3>
					<a href="#">int zrecvfrom(int sockfd, void *buf,
						size_t len, int flags, struct sockaddr *from, socklen_t *fromlen);</a>
				</h3>
				<div class="manual" id="zrecvfrom">
					<h5
						id="int-zrecvfrom-int-sockfd-void-buf-size_t-len-int-flags-struct-sockaddr-from-socklen_t-fromlen">
						int zrecvfrom ( int <em>sockfd</em>, void * <em>buf</em>, size_t <em>len</em>,
						int <em>flags</em>, struct sockaddr * <em>from</em>, socklen_t * <em>fromlen</em>
						)
					</h5>
					<p>zrecvfrom() call intercepts the recv system call.</p>
					<p>zrecvfrom() call may be used when the socket is in any
						(connected or not) state.</p>
					<p>the following call</p>
					<pre><code>zrecv (sockfd,buf, len, flags);</code></pre>
					<p>
						is equivalent to
					</p>
					<pre><code>zrecvfrom (sockfd, buf, len, flags, NULL, 0);</code></pre>
					<h6 id="example-usage">Example usage:</h6>
					<pre><code>int bytes_recv;
int server_sock;
char data_recv[256];
struct sockaddr client_addr;
socklen_t addr_len;
&#8942;
bytes_recv =
zrecvfrom (server_sock, data_recv, sizeof(data_recv), 0, (struct sockaddr *) &amp;client_addr, (int *) &amp;addr_len);</code></pre>
					<h6 id="parameters">Parameters</h6>
					<table>
						<thead>
							<tr>
								<th>Parameter</th>
								<th style="text-align: left">Description</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>sockfd</td>
								<td style="text-align: left">The sockfd argument is a file
									descriptor that refers to a socket of type SOCK_DGRAM.</td>
							</tr>
							<tr>
								<td>buf</td>
								<td style="text-align: left">the message is found in buf</td>
							</tr>
							<tr>
								<td>len</td>
								<td style="text-align: left">length of data to send in buf</td>
							</tr>
							<tr>
								<td>flags</td>
								<td style="text-align: left">see send manual or follow link
									below to see possible flags</td>
							</tr>
							<tr>
								<td>from</td>
								<td style="text-align: left">address of sockaddr stored in
									this location</td>
							</tr>
							<tr>
								<td>fromlen</td>
								<td style="text-align: left">address of socklen_t, the
									length is stored after call</td>
							</tr>
						</tbody>
					</table>


					<h6 id="returns">Returns</h6>
					<p>These calls return the number of bytes received, or -1 if an
						error occurred. The return value will be 0 when the peer has
						performed an orderly shutdown.</p>
					<h6 id="see-also">See Also</h6>
					<p><a href="#">zrecv ()</a></p>
					<p>
						recvfrom <a
							href="http://man7.org/linux/man-pages/man2/recvfrom.2.html">man
							recv</a>
					</p>
					<hr>
				</div>

				<h3>
					<a href="#">int zclose( int sockfd );</a>
				</h3>
				<div class="manual" id="zclose">
					<h5 id="int-zclose-int-sockfd">
						int zclose ( int <em>sockfd</em> )
					</h5>
					<p>zclose() call intercepts the close system call.</p>
					<p>The zclose() function shuts down a socket and frees
						resources allocated to that socket, including those allocated by
						zerosocket library. do not call close as this results in a memory
						leak.</p>
					<h6 id="example-usage">Example usage:</h6>
					<pre><code>#include &quot;zerosocket.h&quot;
&#8942;
int rc;
int server_sock;
&#8942;
rc = zclose(server_sock);
exit(0);</code></pre>
					<h6 id="parameters">Parameters</h6>
					<p>sockfd file descriptor used generated from zsocket call</p>
					<h6 id="returns">Returns</h6>
					<p>zclose() returns zero on success. On error, -1 is returned,
						and errno is set appropriately.</p>
					<h6 id="see-also">See Also</h6>
					<p><a href="#">zsocket ()</a></p>
					<p>
						close <a href="http://man7.org/linux/man-pages/man2/close.2.html">man
							close</a>
					</p>
					<hr>
				</div>
			</div>
			<h2>
				<a name="other-info" class="anchor" href="#other-info"><span
					class="octicon octicon-link"></span></a>Other info
			</h2>

			<p>
				This software is distributed under <a
					href="http://www.gnu.org/licenses/gpl-2.0.html">GPLv2 license</a>,
				so feel free to integrate it in your commercial products.
			</p>

			<p>
				Thanks to Serge Zaitsev for jsmn library (<a
					href="http://zserge.bitbucket.org/jsmn.html">http://zserge.bitbucket.org/jsmn.html</a>).
				I've included the source as is, but would be publishing enhancements
				in the near future.
			</p>

			<p>This repository will be ready for use by Aug 20, 2014</p>
		</section>
		<footer>
			<p>
				<small>Hosted on <a href="http://pages.github.com">GitHub
						Pages</a> using the Dinky theme
				</small>
			</p>
		</footer>
	</div>
	<!--[if !IE]><script>fixScale(document);</script><![endif]-->

</body>
</html>
